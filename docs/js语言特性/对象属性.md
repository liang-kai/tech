# javascript 对象属性的操作

ECMA-262第五版在定义只有内部才用的特性的时候，描述了属性的各种特征。实现这些特征是给 javascript 引擎用的，因此人为增加了一些难度，比如属性都用两个方括号套起来。而这种属性类型在部分场景的事件中可以带来很大的便利性，比如vue里的数据绑定。能操作好属性，在设计上又多了一层想象空间。

记得，数组、函数，都是对象，都有属性的各种特性。只是平时用不会对数组进项这样的操作罢了。proxy 的方法倒是给了函数一些想象力。

```javascript
var person = {
  name : 'Nichoias',
  age : 27,
  job : 'Software Engineer',
  sayName(){
    alert(this.name)
  }
}

```
我们都知道，引用类型存储在内存的堆空间，如上 person 变量指向堆空间的某个地址。其中的 name 属性当做简单类型看待？no!no!no! 如果这样想，那就是把执行上下文的变量概念和引用类型存取的概念搞混了。对象属性的数据存取，更像是有个代理人在打理，就像redux里的reducer一样，内部定义了一套逻辑，只能接受特定的命令、不可以乱来。


## 属性类型

分为数据属性和访问器属性

1. **数据属性**，四个描述其特性的属性是：
  - `[[ Configurable ]]`  
    默认 *true*, 如果为false，则被冻住了，有三层意思：  
    1. 不可 *delete* 删除
    2. 不可修改属性特性（一旦设置为*false*,则属性值就改不了了，简直不可逆啊，冷冻属性利器啊）
    3. 不能把属性值修改为访问器属性
  - `[[ Enumerable ]]` 可否使用 *for...in...* 枚举
  - `[[ Writable ]]` 是否可修改
  - `[[ Value ]]` 真正的值



2. 访问器属性
  - `[[ Configurable ]]` 与上面类似，不过为*false*的第三点需要反过来，不能改为数据属性
  - `[[ Enumerable ]]` 与上面相同
  - `[[ Get ]]` 获取值
  - `[[ Set ]]` 设置值，可接受新值作为参数

要改变属性值，可以用 *Object.defineProperty()* 方法,这也是定义单一属性的方式，注意传参。使用了*Object*上方法，而不是原型链上的，说明不是自家人，而是亲戚家的，设计者确实没想让你方便地操作对象属性。
```javascript
  var obj = {}
  Object.defineProperty(obj, 'name', {
    configurable: true,
    enumerable: true,
    value: 'wang'
    
  })

  var age = 3

  Object.defineProperty(obj, 'age', {
    get(){
      return age;
    },
    set(v){
      age = v + 1;
    }
  })
  obj.age = 1
  console.log(obj, obj.age) // {name: "wang"} 2
```


为啥要分数据属性和访问器属性呢？  
从上面打印输出的结果可以窥探一二：数据属性是能打印出来的值，而访问器属性是隐藏的（就像__proto__一样）（就像一个，不，一对幽灵一样，能存能取但就是看不到它，存取逻辑有关联但不一样）
粗略理解为，一个实体属性，一个是幽灵属性，这两类。  


为什么都有 *configurable* 和 *enumerable* 属性？  
这个问题隐含的条件是同一个属性名，一般，我们不会定义一个属性一会是实体属性，一会又是幽灵属性。虽然属性有两种分类，但一个属性名，同一时间只有一个身份。


## 定义属性&读取属性  

上述的*Object.defineProperty()*方法可以定义单一属性，批操作也是可以有的，那就是*Object.defineProperties()* 方式。
```javascript
  var book = {}
  Object.defineProperties(book, {
    _year:{
      value: 2004
    },
    edition:{
      value: 1
    },
    year:{
      get(){
        return this._year
      },
      
      set(newValue){
        if(newValue > 2004){
          this._year = newValue
          this.edition= newValue - 2004;
        }
      }
    }
  })
```
看着这个例子，是不是有点像闭包的功能了。*_year*变量理解为内部变量（虽然外部能访问到,但不可变writable=false，不可遍历枚举enumeable=false,冻住了configurable=false），存取*year*值都是对此值的操作。*year*同时也像代理人的意思。  


读取属性，使用 *Object.getOwnPropertyDescriptor()* 方法。
```javascript
  // 读取上例的book
  var descriptor = Object.getOwnPropertyDescriptor(book, '_year')
  alert(descriptor.value) // 2004
  alert(descriptor.configurable)  // false
  alert(typeof descriptor.get)  // undefined

  var descriptor = Object.getOwnPropertyDescriptor(book, 'year')
  alert(descriptor.value) // undefined
  alert(descriptor.configurable)  // false
  alert(typeof descriptor.get)  // function
```

## Proxy


## Reflect





参考：
1. [JavaScript 高级程序设计]





