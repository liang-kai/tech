# 浏览器中的javasxript执行机制

## 变量提升

所谓变量提升，是javascript引擎在运行代码之前会做编译，把function类型、var声明前置，function 类型会赋值一个引用类型的地址，而var 声明会初始化undefined

由于js的发明人没有预料到js发展的迅猛，当初设计时候图简单，留下了这个遗憾。ES6的let\const弥补了这个缺陷。

## 执行上下文 和 调用栈

```javascript
var a = 8;
function foo(){

    console.log(a)
}
foo()
```

执行上下文包括了当前变量环境和词法环境。

代码在执行的时候，首先会有个全局的执行上下文，如上代码的话，变量a 和 foo 存在在变量环境

接下来foo执行，把foo拿出来，编译后再创建一个执行上下文，等foo执行完毕，该上下文销毁。

函数调用比较多，那么怎么管理这些上下文呢？这就用到了调用栈。

栈都知道，先进后出。先把全局上下文压进栈底，等函数执行时候，同样压入栈中，执行完后弹出。这样的一种结构，叫调用栈。

常常遇见的栈溢出是怎么回事呢？栈是内存里的一块空间，总是有大小的，如果入栈太多，会溢出。常见于递归调用未终止的情况。

使用console.trace()或debug能看出调用栈的父子关系。

## let 和 const 何如实现

先提一个词————`作用域`，作用域就是 变量和函数的可访问范围，控制着变量和函数的可见性和生命周期。

ES6 之前，只有两种作用域，全局作用域和函数作用域。没有块级作用域。

因为变量提升、没有块级作用域会制约js发展，于是解决方案出来了——let 和 const.

```javascript
    function foo(){
        var a = 8
        let b = 5
        {
            var c = 2
            let d = 4
            console.log(b)
        }
        console.log(c)
        console.log(d)
    }
```
1. 如上函数编译出来的执行上下文中，变量环境会有a\c,词法环境会有b
2. 执行到函数内的{}时候，a\b已经赋值，会在词法环境(栈结构)压入新的变量d
3. 变量查找的过程顺序是，先从词法结构的栈结构找，然后才是变量环境。

注意，var 变量会声明并且初始化； let/const 会声明，但不会初始化，在赋值之前调用let变量会报错的（这是个暂时性死区）；function 不仅声明，还赋值。

## 作用域链和闭包

先定义下词法作用域——是指作用域由函数声明时候的位置来决定。

作用域链，就是指词法作用域链，查找变量的链。

在词法作用域的基础上理解闭包就容易了。

```javascript
function foo(){
    var a = 0
    return {
        getA:function(){
            return a
        }
    }
}
```
根据词法作用域，外部函数返回的内部函数可以调用外部函数的变量，即使外部函数执行完毕，内部函数中访问的外部函数的变量还是会保存在执行上下文中的，属于这个返回的内部函数的专属变量区域（closure），这就是闭包机制。


## this机制

对象内部的方法调用对象内部的属性，是一个非常常见的需求，但是JS当前作用域并不支持这样的需求，于是有了this。

this 和执行上下文有关：
1. 全局执行上下文
2. 函数执行上下文，改变this,有如下方式
    1. call/apply/bind
    2. 对象调用
    3. 构造函数内部

箭头函数没有执行上下文，会继承外层的this



