# 从输入URL到页面展示发生了什么

## 浏览器的进程

当前大多浏览器都是基于google开源的Chromium二次开发的，Chrome作为google的官方浏览器，特性和Chrominum基本一致。用Chrome来说下浏览器的进程。

先区分下进程和线程，进程是程序的运行实例，操作系统会分配一块独立的内存空间存放代码、数据来作为运行环境。进程间通信通过IPC机制。线程是进程开辟的计算单元，同一进程的不同线程可以共享运行时代码、数据。

Chrome基础共享进程有三个：
1. 浏览器进程：负责用户交互、子进程管理、文件存储等
2. 网络进程：提供网络通信功能
3. GPU进程：绘制图层

还有两个不定数量的进程：
1. 渲染进程： 每个同源页面会分配一个进程，解析html\css\js,排版引擎Blink和js引擎V8都是在这个进程里。
2. 插件进程：之所以把插件独立出来，是为了避免插件问题引起的崩溃问题。


## HTTP 和 TCP介绍

HTTP是应用层协议，TCP是传输层协议。

一个数据包加上IP和端口号，在两个机器的应用之间通过网络进行传送，这样的协议我们叫`UDP`。一个数据包最多14k,数据多那就需要进行拆分、发送、组装才能正确地通信，UDP满足不了，所有有个TCP。确保数据通过复杂的网络也能被正确的接收到，实现了丢包重传、以及数据序列机制。

TCP分三个阶段：
1. 建立连接。
2. 传输数据。
3. 断开连接。
TODO：待完善

HTTP是TCP协议之上，也就是HTTP的内容会被TCP协议包裹了发出去。
可分为请求行、请求头、请求体。

请求行又包括：
1. 请求方法
    - `get` 获取
    - `post` 创建或修改
    - `delete` 删除
    - `put` 整体更新
    - `patch` 部分更新
    - `head` 只需要相应头
2. 请求地址
3. 请求协议

请求头代表当前环境信息，也就是浏览器信息，部分包括：

`user-agent`: 浏览器信息（版本、厂商、内核等）
`accept-lauguage`: 语言
`accept`: 期望接收格式
`accept-encoding`: 期望压缩格式
`referer`: 当前请求页面来源
`host`: 当前页面host
`cookie`: 可以在客户端和服务端来回通信的、可持久存储的数据,一个重要的作用是用来标识用户
`connection`: 是否持久链接，if yes,下次tcp链接建立就免了

响应头是服务端的应答，部分包括：

`content-encoding`: 编码格式
`content-length`: 数据大小
`content-type`: 数据格式
`date`: 时间
`last-modified`: 最后一次修改时间
`location`: 状态为转移的时候标明转移地址
`set-cookie`: 设置cookie

## 开始请求

从导航栏输入地址或内容（内容会被浏览器转为地址），到页面呈现是个漫长的说明过程，咱们慢慢来。

导航栏有了地址，譬如[http://baidu.com](http://baidu.com)，按下回车，这时浏览器就哗啦啦滴卖力工作了。

1. 浏览器进程处理用户输入，交给网络进程发起http请求
2. 网络进程：
    1. DNS查询ip
    2. 准备TCP链接，如果同一域名的tcp超出限额（6），等待
    3. 发起http请求，接收相应头之后通知浏览器进程
3. 浏览器进程准备渲染进程
    1. 网络进程把响应体数据给了渲染进程
    2. 渲染进程通知浏览器进程确认提交了文档，浏览器进程进行页面状态栏变更
4. 渲染进程解析文档、请求子资源、绘制（1-5在主线程执行，之后是合成线程，重排、重绘都会影响主线程，而translate属性直接在合成线程操作，不影响主线程，显得流畅）
    1. `构建DOM树`  html ==> DOM 树构建
    2. `计算样式`   层叠样式表的计算，标准化处理
    3. `构建布局树` DOM 和 样式 构建成书，只展示需要的，display:none 的就算了
    4. `分层`   和PS一样，需要分图层的，有层叠上下文属性的元素（display:fixed; opacity: .5; filter:blue(1px); z-index:2）\ 有overflow内容溢出展示的 都会单独拉出一层，除此之外的元素在一个主图层。
    5. `绘制列表`   图层分好了，接下来绘制，会生成绘制列表（描述文件）
    6. `分块、栅格化`   视窗比页面一般小很多，保证视窗的优先加载对体验很重要。按照某个尺寸（256x256或512x512）把图层分块，生成位图（这里要交给GPU进程来做）
    8. `展示`   渲染进程传给浏览器进程消息，展示在屏幕上