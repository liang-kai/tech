(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{218:function(v,_,t){"use strict";t.r(_);var a=t(0),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"v8-工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-工作原理","aria-hidden":"true"}},[v._v("#")]),v._v(" V8 工作原理")]),v._v(" "),t("h2",{attrs:{id:"堆栈结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆栈结构","aria-hidden":"true"}},[v._v("#")]),v._v(" 堆栈结构")]),v._v(" "),t("p",[v._v("先理解几个概念：")]),v._v(" "),t("p",[v._v("静态语言 VS 动态语言：在使用之前需要确定变量数据类型的是静态语言，动态语言反之")]),v._v(" "),t("p",[v._v("强类型 VS 弱类型：变量不会隐式转换，为强类型，弱类型反之。")]),v._v(" "),t("p",[v._v("js 是动态弱类型。")]),v._v(" "),t("p",[v._v("基本类型有8中：\n7种原始类型： String/Number/BigInt/Boolean/Null/Undefined/Symbol\n1中引用类型：Object")]),v._v(" "),t("p",[v._v("内崔中结构分为：")]),v._v(" "),t("ol",[t("li",[v._v("代码段")]),v._v(" "),t("li",[v._v("栈")]),v._v(" "),t("li",[v._v("堆")])]),v._v(" "),t("ul",[t("li",[v._v("原始类型的数据以值的形式保存在栈环境中，引用类型的数据（包括function）以引用地址的形式存在栈中，其数据保存在堆中")])]),v._v(" "),t("h2",{attrs:{id:"垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制","aria-hidden":"true"}},[v._v("#")]),v._v(" 垃圾回收机制")]),v._v(" "),t("p",[v._v("为了解放程序员生产力，需要垃圾自动回收机制，而不是手动释放。")]),v._v(" "),t("p",[v._v("栈空间怎么释放？调用栈有个指针，指向当前执行栈，也就是栈顶，一旦栈顶函数执行完毕，指针退回下一级，此时之前的空间就算释放了。")]),v._v(" "),t("p",[v._v("那么，如果之前函数里在堆空间里存放了数据，怎么释放？")]),v._v(" "),t("p",[v._v("堆数据高效回收有两个假设？")]),v._v(" "),t("ol",[t("li",[v._v("多数引用类型的数据量不大，且存在周期很短，当前函数上下文执行完毕择无用。")]),v._v(" "),t("li",[v._v("存在时间上的数据，则更可能存活更长时间。\n加上调用栈的上下文环境中可以找到那些还活动的对象，标记出不活动的，从而达到可以自动回收的条件。")])]),v._v(" "),t("p",[v._v("实践中在垃圾回收中做了哪些算法优化呢？")]),v._v(" "),t("p",[v._v("把堆空间分为两部分：\n一个是新生代空间，空间较小，通常1~8M，用来存储新来的小的数据（大的数据因为需要空间大，会存在另一个里），基于假设一，扫描会频繁；\n二个是老生代空间，空间较大，存储大的数据以及经过新生代里经过垃圾回收机制扫描两次还存活的数据")]),v._v(" "),t("p",[v._v("两类堆空间在回收空间的时候，都会经过 扫描调用栈标记不活动对象、清除不活动对象、空间整合，但也有区别：")]),v._v(" "),t("ol",[t("li",[v._v("新生代空间小，有助于清理空间，不会长时间阻塞主线程。这个空间内又对半分成两部分，一半空闲、一半活动区。垃圾回收机制回收活动区的时候，把有效的数据复制到空闲区，此时两者角色调换。")]),v._v(" "),t("li",[v._v("老生代因为占用空间大，不能对半分（太消耗空间以及可能阻塞主线程），采用标记-清除的方式，目的是把数据连续放在一块地址中，其余地址就是空闲的了。同时为了不阻塞主线程，采用增亮标记的算法，把整个过程切分。")])]),v._v(" "),t("p",[v._v("如果要追查内存泄露（也就是某些引用没有被释放），可以在控制台看performs里内存是否一直增长。")]),v._v(" "),t("h2",{attrs:{id:"编译器和解释器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译器和解释器","aria-hidden":"true"}},[v._v("#")]),v._v(" 编译器和解释器")]),v._v(" "),t("p",[v._v("V8 拿到一段代码要做些什么事？")]),v._v(" "),t("p",[v._v("首先要做词法分析（AST）的，相当于代码的树状结构，以及生成执行上下文。")]),v._v(" "),t("p",[v._v("然后进行编译，变成字节码。（为啥不是机器码？其实老早之前是机器码，但是手机内存小，机器码太占用空间，于是引入了个中间层——字节码）")]),v._v(" "),t("p",[v._v("最后执行。这期间，如果发现有热点字节码（重复利用率高的），会JIT（即时编译）为机器码一共下次调用。")])])}),[],!1,null,null,null);_.default=r.exports}}]);