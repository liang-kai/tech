(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{208:function(t,a,e){"use strict";e.r(a);var r=e(0),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-实战"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-实战","aria-hidden":"true"}},[t._v("#")]),t._v(" React 实战")]),t._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介","aria-hidden":"true"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("声明式语法可以组织复杂的界面逻辑")]),t._v(" "),e("p",[t._v("繁荣的生态圈，带来大量最佳时间实践")]),t._v(" "),e("p",[t._v("活跃的技术社区，快速的解决问题")]),t._v(" "),e("h2",{attrs:{id:"历史背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#历史背景","aria-hidden":"true"}},[t._v("#")]),t._v(" 历史背景")]),t._v(" "),e("p",[t._v("（2013年FB推出的）")]),t._v(" "),e("ol",[e("li",[t._v("传统UI的问题：工程师关注太多细节，model-view相互绑定，不好追踪")]),t._v(" "),e("li",[t._v("react 始终整体刷新页面，不用关注细节")]),t._v(" "),e("li",[t._v("Flux 架构-单向数据流，redux\\mobx框架")])]),t._v(" "),e("h2",{attrs:{id:"以组件的方式考虑ui的构建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#以组件的方式考虑ui的构建","aria-hidden":"true"}},[t._v("#")]),t._v(" 以组件的方式考虑UI的构建")]),t._v(" "),e("ol",[e("li",[t._v("以组件化的方式思考")]),t._v(" "),e("li",[t._v("单一职责原则，组件尽可能小，提高性能")]),t._v(" "),e("li",[t._v("状态管理 DRY 原则\n"),e("ul",[e("li",[t._v("计算的状态不要单独存储")]),t._v(" "),e("li",[t._v("组件尽量无状态，所需数组通过props获取")])])])]),t._v(" "),e("h2",{attrs:{id:"jsx不是模板语法，而是语法糖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jsx不是模板语法，而是语法糖","aria-hidden":"true"}},[t._v("#")]),t._v(" JSX不是模板语法，而是语法糖")]),t._v(" "),e("p",[t._v("优点：")]),t._v(" "),e("ol",[e("li",[t._v("声明式创建UI")]),t._v(" "),e("li",[t._v("代码创建模板的灵活性")])]),t._v(" "),e("h2",{attrs:{id:"生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),e("p",[t._v("constructor 初始化内部状态(不常使用))；唯一可以直接修改state的地方\ngetDerievedStateFromProps (名字这么长，就是不像让用)\n- 当state 需要从props初始化时使用\n- 尽量不要用，维护两者状态一致性增加复杂度\n- 典型应用场景：表单控件的默认值\n- 每次render都会调用。毕竟是代替原来的componentWillRecieveProps的")]),t._v(" "),e("p",[t._v("componentDidMount 只执行一次，获取网络请求\ngetSnapShotBeforeUpdate 更新前获取前一个状态的属性的节点\ncomponentDidUpdate  根据props变化重新执行\nshouldCompentUpdate")]),t._v(" "),e("h2",{attrs:{id:"vdom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vdom","aria-hidden":"true"}},[t._v("#")]),t._v(" VDOM")]),t._v(" "),e("p",[t._v("两个假设：")]),t._v(" "),e("ol",[e("li",[t._v("组件的DOM结构相对稳定")]),t._v(" "),e("li",[t._v("类型相同的兄弟节点可以被唯一标识")])]),t._v(" "),e("h2",{attrs:{id:"高阶组件-和-函数作为子组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件-和-函数作为子组件","aria-hidden":"true"}},[t._v("#")]),t._v(" 高阶组件 和 函数作为子组件")]),t._v(" "),e("h2",{attrs:{id:"context-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context-api","aria-hidden":"true"}},[t._v("#")]),t._v(" context api")]),t._v(" "),e("p",[t._v("createContext")]),t._v(" "),e("p",[t._v("Provider")]),t._v(" "),e("p",[t._v("Consumer")]),t._v(" "),e("h2",{attrs:{id:"脚手架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脚手架","aria-hidden":"true"}},[t._v("#")]),t._v(" 脚手架")]),t._v(" "),e("p",[t._v("create React app")]),t._v(" "),e("h2",{attrs:{id:"打包和部署"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#打包和部署","aria-hidden":"true"}},[t._v("#")]),t._v(" 打包和部署")]),t._v(" "),e("p",[t._v("为啥需要：")]),t._v(" "),e("ol",[e("li",[t._v("编译ES6 语法")]),t._v(" "),e("li",[t._v("整合资源、例如图片、less")]),t._v(" "),e("li",[t._v("优化体积")])]),t._v(" "),e("h2",{attrs:{id:"redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux","aria-hidden":"true"}},[t._v("#")]),t._v(" redux")]),t._v(" "),e("p",[t._v("状态管理框架")]),t._v(" "),e("p",[t._v("可预测性")])])}),[],!1,null,null,null);a.default=v.exports}}]);